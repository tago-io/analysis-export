/*
 * TagoIO (https://tago.io/)
 * TagoIO Builder V3.0.3 (https://git.io/JJ8Si)
 * -------------------
 * Generated by     :: vitorfdl
 * Generated at     :: Thursday, March 24, 2022, 5:08 PM Coordinated Universal Time
 * Machine          :: DESKTOP-AAAF60B <linux> - Node.js v16.13.2
 * Origin file      :: src/startAnalysis.ts <Typescript>
 * Destination file :: src/startAnalysis.tago-io.js
 * -------------------
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, copyDefault, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && (copyDefault || key !== "default"))
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toESM = (module2, isNodeMode) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", !isNodeMode && module2 && module2.__esModule ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __toCommonJS = /* @__PURE__ */ ((cache) => {
  return (module2, temp) => {
    return cache && cache.get(module2) || (temp = __reExport(__markAsModule({}), module2, 1), cache && cache.set(module2, temp), temp);
  };
})(typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : 0);

// src/startAnalysis.ts
var startAnalysis_exports = {};
__export(startAnalysis_exports, {
  default: () => startAnalysis_default
});
var import_sdk3 = require("@tago-io/sdk");
var import_axios2 = __toESM(require("axios"));

// src/lib/data.logic.ts
function parseTagoObject(body, serie) {
  if (!serie) {
    serie = String(new Date().getTime());
  }
  return Object.keys(body).map((item) => {
    return {
      variable: item,
      value: body[item] instanceof Object ? body[item].value : body[item],
      serie,
      time: body[item] instanceof Object ? body[item].time : null,
      location: body[item] instanceof Object ? body[item].location : null,
      metadata: body[item] instanceof Object ? body[item].metadata : null
    };
  }).filter((item) => item.value !== null && item.value !== void 0);
}

// src/lib/auditLogSetup.ts
function auditLogSetup(account, device, log_variable) {
  if (!log_variable) {
    log_variable = "auditlog";
  }
  return async function _(description) {
    if (!description) {
      throw "Missing description";
    }
    device.sendData(parseTagoObject({
      [log_variable]: { value: description }
    }, String(new Date().getTime())));
    return description;
  };
}

// src/lib/validation.ts
function validation(validation_var, device, show_markdown) {
  return function _(message, type) {
    if (!message || !type) {
      throw "Missing message or type";
    }
    device.sendData({
      variable: validation_var,
      value: message,
      metadata: {
        type: ["success", "danger", "warning"].includes(type) ? type : null,
        color: !["success", "danger", "warning"].includes(type) ? type : null,
        show_markdown
      }
    });
    return message;
  };
}

// src/lib/replaceObj.ts
function replaceObj(original, replacer) {
  let string_obj = JSON.stringify(original);
  for (const key in replacer) {
    string_obj = string_obj.replace(new RegExp(key, "g"), replacer[key]);
  }
  return JSON.parse(string_obj);
}
var replaceObj_default = replaceObj;

// src/services/accessExport.ts
async function accessExport(account, import_account, export_holder) {
  console.info("Exporting access rules: started");
  const list = await account.accessManagement.list({ amount: 99, fields: ["id", "name", "tags"], filter: { tags: [{ key: "export_id" }] } });
  const import_list = await import_account.accessManagement.list({ amount: 99, fields: ["id", "tags"], filter: { tags: [{ key: "export_id" }] } });
  for (const { id: access_id, tags: access_tags, name } of list) {
    console.info(`Exporting access rule ${name}`);
    const access = await account.accessManagement.info(access_id);
    const export_id = access.tags.find((tag) => tag.key === "export_id")?.value;
    let { id: target_id } = import_list.find((access2) => access2.tags.find((tag) => tag.key === "export_id" && tag.value == export_id)) || { id: null };
    const new_access = replaceObj_default(access, { ...export_holder.devices, ...export_holder.dashboards });
    if (!target_id) {
      ({ am_id: target_id } = await import_account.accessManagement.create(new_access));
    } else {
      await import_account.accessManagement.edit(target_id, new_access);
    }
  }
  console.info("Exporting access rules: finished");
  return export_holder;
}
var accessExport_default = accessExport;

// src/services/actionsExport.ts
async function actionsExport(account, import_account, export_holder) {
  console.info("Exporting actions: started");
  const list = await account.actions.list({ amount: 99, fields: ["id", "name", "tags"], filter: { tags: [{ key: "export_id" }] } });
  const import_list = await import_account.actions.list({ amount: 99, fields: ["id", "tags"], filter: { tags: [{ key: "export_id" }] } });
  for (const { id: action_id, tags: action_tags, name } of list) {
    console.info(`Exporting action ${name}`);
    const action = await account.actions.info(action_id);
    const export_id = action.tags.find((tag) => tag.key === "export_id")?.value;
    let { id: target_id } = import_list.find((action2) => action2.tags.find((tag) => tag.key === "export_id" && tag.value == export_id)) || { id: null };
    const new_action = replaceObj_default(action, { ...export_holder.devices, ...export_holder.analysis });
    for (const trigger of new_action.trigger) {
      if (!trigger.value)
        delete trigger.value;
      if (!trigger.second_value)
        delete trigger.second_value;
      if (trigger.tag_key)
        delete trigger.unlock;
    }
    if (!target_id) {
      ({ action: target_id } = await import_account.actions.create(new_action));
    } else {
      await import_account.actions.edit(target_id, new_action);
    }
  }
  console.info("Exporting actions: finished");
  return export_holder;
}
var actionsExport_default = actionsExport;

// src/services/analysisExport.ts
var import_zlib = __toESM(require("zlib"));
var import_axios = __toESM(require("axios"));
async function analysisExport(account, import_account, export_holder) {
  console.info("Exporting analysis: started");
  const list = await account.analysis.list({ amount: 99, fields: ["id", "name", "tags"], filter: { tags: [{ key: "export_id" }] } });
  const import_list = await import_account.analysis.list({ amount: 99, fields: ["id", "tags"], filter: { tags: [{ key: "export_id" }] } });
  for (const { id: analysis_id, name } of list) {
    console.info(`Exporting dashboard ${name}...`);
    const analysis = await account.analysis.info(analysis_id);
    const export_id = analysis.tags.find((tag) => tag.key === "export_id")?.value;
    let { id: target_id } = import_list.find((analysis2) => analysis2.tags.find((tag) => tag.key === "export_id" && tag.value == export_id)) || { id: null };
    const new_analysis = replaceObj_default(analysis, { ...export_holder.devices, ...export_holder.tokens });
    if (!target_id) {
      ({ id: target_id } = await import_account.analysis.create(new_analysis));
    } else {
      await import_account.analysis.edit(target_id, {
        name: new_analysis.name,
        tags: new_analysis.tags,
        active: new_analysis.active,
        variables: new_analysis.variables
      });
    }
    const script = await account.analysis.downloadScript(analysis_id);
    const script_base64 = await import_axios.default.get(script.url, {
      responseType: "arraybuffer"
    }).then((response) => import_zlib.default.gunzipSync(response.data).toString("base64"));
    await import_account.analysis.uploadScript(target_id, { content: script_base64, language: "node", name: "script.js" });
    export_holder.analysis[analysis_id] = target_id;
  }
  console.info("Exporting analysis: finished");
  return export_holder;
}
var analysisExport_default = analysisExport;

// src/services/collectIDs.ts
var import_sdk = require("@tago-io/sdk");
async function collectIDs(account, import_account, entity, export_holder) {
  const list = await account[entity].list({
    page: 1,
    amount: 99,
    fields: ["id", "tags"],
    filter: { tags: [{ key: "export_id" }] }
  });
  const import_list = await import_account[entity].list({
    page: 1,
    amount: 99,
    fields: ["id", "tags"],
    filter: { tags: [{ key: "export_id" }] }
  });
  for (const item of list) {
    const export_id = item.tags.find((tag) => tag.key === "export_id")?.value;
    if (!export_id) {
      continue;
    }
    const { id: target_id } = import_list.find((a) => a.tags.find((tag) => tag.key === "export_id" && tag.value == export_id)) || {
      id: null
    };
    if (!target_id) {
      continue;
    }
    if (entity === "devices") {
      const token = await import_sdk.Utils.getTokenByName(account, item.id);
      const target_token = await import_sdk.Utils.getTokenByName(import_account, target_id);
      if (token && target_token) {
        export_holder.tokens[token] = target_token;
      }
    }
    export_holder[entity][item.id] = target_id;
  }
  return export_holder;
}
var collectIDs_default = collectIDs;

// src/services/widgetsExport.ts
async function insertWidgets(account, import_account, dashboard, target, export_holder) {
  const widget_ids = dashboard.arrangement.map((x) => x.widget_id);
  const widgets = await Promise.all(widget_ids.map((x) => account.dashboards.widgets.info(dashboard.id, x)));
  const hidden_tabs = dashboard.tabs.filter((tab) => !tab.hidden).map((tab) => tab.key);
  const arrangement = dashboard.arrangement.sort((a) => hidden_tabs.includes(a.tab) ? 1 : -1);
  const new_arrangement = [];
  const widget_holder = {};
  for (const widget_arrangement of arrangement) {
    const widget = widgets.find((wdgt) => widget_arrangement.widget_id === wdgt.id);
    const new_widget = replaceObj_default(widget, { ...export_holder.analysis, ...export_holder.devices, ...widget_holder });
    if (new_widget.data) {
      new_widget.data = new_widget.data.map((x) => {
        if (x.qty) {
          x.qty = Number(x.qty);
        }
        return x;
      });
    }
    const { widget: new_id } = await import_account.dashboards.widgets.create(target.id, new_widget);
    new_arrangement.push({ ...widget_arrangement, widget_id: new_id });
    widget_holder[widget.id] = new_id;
  }
  await import_account.dashboards.edit(target.id, { arrangement: new_arrangement });
}
async function removeAllWidgets(import_account, dashboard) {
  await Promise.all(dashboard.arrangement.map((widget) => import_account.dashboards.widgets.delete(dashboard.id, widget.widget_id)));
}

// src/services/dashboardsExport.ts
async function resolveDashboardTarget(import_account, export_id, import_list, content) {
  const import_dashboard = import_list.find((dash) => {
    const import_id = dash.tags?.find((tag) => tag.key === "export_id")?.value;
    return import_id && import_id === export_id;
  });
  if (import_dashboard) {
    const dashboard = await import_account.dashboards.info(import_dashboard.id);
    return dashboard;
  }
  const { dashboard: dashboard_id } = await import_account.dashboards.create({ ...content, arrangement: null });
  await import_account.dashboards.edit(dashboard_id, { ...content, arrangement: null });
  return import_account.dashboards.info(dashboard_id);
}
async function dashboardExport(account, import_account, export_holder) {
  console.info("Exporting dashboard: started");
  const list = await account.dashboards.list({ page: 1, amount: 99, fields: ["id", "label", "tags"], filter: { tags: [{ key: "export_id" }] } });
  const import_list = await import_account.dashboards.list({ page: 1, amount: 99, fields: ["id", "label", "tags"], filter: { tags: [{ key: "export_id" }] } });
  for (const { id: dash_id, label } of list) {
    console.info(`Exporting dashboard ${label}...`);
    const dashboard = await account.dashboards.info(dash_id);
    const export_id = dashboard.tags.find((tag) => tag.key === "export_id")?.value;
    if (!export_id)
      continue;
    const dash_target = await resolveDashboardTarget(import_account, export_id, import_list, dashboard);
    await removeAllWidgets(import_account, dash_target);
    dash_target.arrangement = [];
    await insertWidgets(account, import_account, dashboard, dash_target, export_holder);
    export_holder.dashboards[dash_id] = dash_target.id;
  }
  console.info("Exporting dashboard: finished");
  return export_holder;
}
var dashboardsExport_default = dashboardExport;

// src/services/devicesExport.ts
var import_sdk2 = require("@tago-io/sdk");

// src/config.ts
var config = {
  export_tag: "export_id",
  entities: ["devices", "analysis", "dashboards", "accessManagement", "run_buttons", "actions", "dictionaries"],
  export: {
    token: ""
  },
  import: {
    token: "7ec20119-e7e4-4605-a913-51c74dd78614"
  }
};
var config_default = config;

// src/services/devicesExport.ts
async function deviceExport(account, import_account, export_holder) {
  console.info("Exporting devices: started");
  const list = await account.devices.list({
    amount: 99,
    fields: ["id", "name", "tags"],
    filter: { tags: [{ key: "export_id" }] }
  });
  const import_list = await import_account.devices.list({
    amount: 99,
    fields: ["id", "tags"],
    filter: { tags: [{ key: "export_id" }] }
  });
  for (const { id: device_id, tags: device_tags, name } of list) {
    console.info(`Exporting devices ${name}`);
    const device = await account.devices.info(device_id);
    const export_id = device.tags.find((tag) => tag.key === "export_id")?.value;
    const token = await import_sdk2.Utils.getTokenByName(account, device_id);
    let { id: target_id } = import_list.find((device2) => device2.tags.find((tag) => tag.key === "export_id" && tag.value == export_id)) || { id: null };
    let new_token;
    const new_device = replaceObj_default(device, export_holder.devices);
    new_device.last_input = void 0;
    new_device.last_output = void 0;
    new_device.bucket = new_device.type;
    if (!target_id) {
      ({ device_id: target_id, token: new_token } = await import_account.devices.create(new_device));
      if (config_default.data && config_default.data.length) {
        const device2 = new import_sdk2.Device({ token: new_token });
        const old_device = new import_sdk2.Device({ token });
        const data = await old_device.getData({
          variables: config_default.data,
          qty: 9999
        });
        if (data.length) {
          device2.sendData(data);
        }
      }
    } else {
      await import_account.devices.edit(target_id, {
        ...new_device,
        connector: null,
        network: null
      });
      new_token = await import_sdk2.Utils.getTokenByName(import_account, target_id);
    }
    export_holder.devices[device_id] = target_id;
    export_holder.tokens[token] = new_token;
  }
  console.info("Exporting devices: finished");
  return export_holder;
}
var devicesExport_default = deviceExport;

// src/services/dictionaryExport.ts
async function dictionaryExport(account, import_account, export_holder) {
  console.info("Exporting dictionaries: started");
  const list = await account.dictionaries.list({ amount: 99, fields: ["id", "slug", "languages", "name", "fallback"] });
  const import_list = await import_account.dictionaries.list({ amount: 99, fields: ["id", "slug", "languages", "name", "fallback"] });
  for (const item of list) {
    console.info(`Exporting dictionary ${item.name}`);
    let { id: target_id } = import_list.find((dict) => dict.slug === item.slug) || { id: null };
    if (!target_id) {
      ({ dictionary: target_id } = await import_account.dictionaries.create(item));
    } else {
      const new_item = { ...item };
      delete new_item.id;
      await import_account.dictionaries.edit(target_id, new_item);
    }
    for (const lang of item.languages) {
      const dictionary = await account.dictionaries.languageInfo(item.id, lang.code);
      import_account.dictionaries.languageEdit(target_id, lang.code, { dictionary, active: true });
    }
  }
  console.info("Exporting dictionaries: finished");
  return export_holder;
}
var dictionaryExport_default = dictionaryExport;

// src/services/runButtonsExport.ts
async function runButtonsExport(account, import_account, export_holder) {
  console.info("Run Buttons: started");
  const run_info = await account.run.info();
  const import_run_info = await import_account.run.info();
  const sidebar_buttons = run_info.sidebar_buttons;
  for (const btn of sidebar_buttons) {
    if (btn.type !== "dashboard") {
      continue;
    }
    btn.value = export_holder.dashboards[btn.value];
  }
  import_run_info.sidebar_buttons = sidebar_buttons;
  for (const template_name of Object.keys(run_info.email_templates)) {
    const email_obj = run_info.email_templates[template_name];
    import_run_info.email_templates[template_name] = email_obj;
  }
  await import_account.run.edit(import_run_info);
  console.info("Run Buttons: finished");
  return export_holder;
}
var runButtonsExport_default = runButtonsExport;

// src/startAnalysis.ts
var config2 = {
  export_tag: "export_id",
  entities: ["devices", "analysis", "dashboards", "accessManagement", "run_buttons", "actions", "dictionaries"],
  data: ["list_devtype_id"],
  export: {
    token: ""
  },
  import: {
    token: ""
  }
};
var IMPORT_ORDER = ["devices", "analysis", "dashboards", "accessManagement", "run_buttons", "actions", "dictionaries"];
async function sendNotification(token, message) {
  (0, import_axios2.default)({
    method: "POST",
    url: "https://api.tago.io/notification",
    data: {
      title: "Importing application",
      message
    },
    headers: { Authorization: config2.import.token }
  });
}
async function startImport(context, scope) {
  const environment = import_sdk3.Utils.envToJson(context.environment);
  if (!environment) {
    return;
  }
  if (!environment.account_token) {
    throw "Missing account_token environment var";
  }
  const main_account = new import_sdk3.Account({ token: environment.account_token });
  const config_dev = await import_sdk3.Utils.getDevice(main_account, scope[0].origin);
  const validate = validation("export_validation", config_dev);
  const export_token = scope.find((x) => x.variable === "export_token");
  const target_token = scope.find((x) => x.variable === "target_token");
  const entities = scope.find((x) => x.variable === "entity_list" && x.metadata?.sentValues);
  const data_list = scope.find((x) => x.variable === "data_list");
  const export_tag = scope.find((x) => x.variable === "export_tag");
  config2.export.token = export_token.value;
  config2.import.token = target_token.value;
  if (!config2.export.token) {
    throw validate("Missing account application token field", "danger");
  } else if (config2.export.token.length !== 36) {
    throw validate('Invalid "account application token".', "danger");
  }
  if (!config2.import.token) {
    throw validate("Missing account token field", "danger");
  } else if (config2.import.token.length !== 36) {
    throw validate('Invalid "account token".', "danger");
  }
  const account = new import_sdk3.Account({ token: config2.export.token });
  const import_account = new import_sdk3.Account({ token: config2.import.token });
  if (entities?.metadata?.sentValues) {
    const values = entities.metadata.sentValues.map((x) => x.value);
    config2.entities = values;
  }
  if (data_list?.value) {
    const data = data_list.value.replace(/ /g, "").split(",");
    config2.data = data;
  }
  if (export_tag?.value) {
    config2.export_tag = export_tag?.value;
  }
  const import_rule = IMPORT_ORDER.filter((entity) => config2.entities.includes(entity));
  let export_holder = {
    devices: {},
    analysis: {},
    dashboards: {},
    tokens: { [config2.export.token]: config2.import.token }
  };
  console.info("====Exporting started====");
  console.log(import_rule);
  if (import_rule.includes("run_buttons")) {
    const run = await import_account.run.info();
    if (!run || !run.name) {
      throw validate("The account doesn't have RUN enabled. Not possible to import RUN Buttons.", "danger");
    }
  }
  const import_acc_info = await import_account.info();
  if (import_acc_info.plan === "free") {
    throw validate("The account is free, can't import the application.", "danger");
  }
  const auditlog = auditLogSetup(account, config_dev, "export_log");
  auditlog(`Starting export to: ${import_acc_info.name}`);
  sendNotification(config2.import.token, "Starting the import proccess. Please await, it can take up to 5 minutes.");
  try {
    validate("Exporting the application, this proccess can take several minutes...", "warning");
    const idCollection = [];
    for (const entity of import_rule) {
      switch (entity) {
        case "devices":
          export_holder = await devicesExport_default(account, import_account, export_holder);
          idCollection.push("devices");
          break;
        case "dashboards":
          if (!idCollection.includes("analysis")) {
            idCollection.push("analysis");
            export_holder = await collectIDs_default(account, import_account, "analysis", export_holder);
          }
          if (!idCollection.includes("devices")) {
            idCollection.push("devices");
            export_holder = await collectIDs_default(account, import_account, "devices", export_holder);
          }
          export_holder = await dashboardsExport_default(account, import_account, export_holder);
          idCollection.push("dashboards");
          break;
        case "accessManagement":
          if (!idCollection.includes("devices")) {
            idCollection.push("devices");
            export_holder = await collectIDs_default(account, import_account, "devices", export_holder);
          }
          if (!idCollection.includes("dashboards")) {
            idCollection.push("dashboards");
            export_holder = await collectIDs_default(account, import_account, "dashboards", export_holder);
          }
          export_holder = await accessExport_default(account, import_account, export_holder);
          break;
        case "analysis":
          if (!idCollection.includes("devices")) {
            idCollection.push("devices");
            export_holder = await collectIDs_default(account, import_account, "devices", export_holder);
          }
          export_holder = await analysisExport_default(account, import_account, export_holder);
          idCollection.push("analysis");
          break;
        case "actions":
          if (!idCollection.includes("devices")) {
            idCollection.push("devices");
            export_holder = await collectIDs_default(account, import_account, "devices", export_holder);
          }
          export_holder = await actionsExport_default(account, import_account, export_holder);
          idCollection.push("actions");
          break;
        case "dictionaries":
          export_holder = await dictionaryExport_default(account, import_account, export_holder);
          break;
        case "run_buttons":
          if (!idCollection.includes("dashboards")) {
            idCollection.push("dashboards");
            export_holder = await collectIDs_default(account, import_account, "dashboards", export_holder);
          }
          export_holder = await runButtonsExport_default(account, import_account, export_holder);
          idCollection.push("run_buttons");
          break;
        default:
          break;
      }
    }
  } catch (e) {
    auditlog(`Error while exporting: ${e}`);
    throw validate(e, "danger");
  }
  sendNotification(config2.import.token, "The application was succesfully imported.");
  auditlog(`Export finished with success for: ${import_acc_info.name}`);
  validate("Application succesfully exported!", "success");
  console.info("====Exporting ended with success====");
}
var startAnalysis_default = new import_sdk3.Analysis(startImport, {
  token: "9a37a7d2-964e-4806-b8dd-06822c0f335c"
});
module.exports = __toCommonJS(startAnalysis_exports);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {});
